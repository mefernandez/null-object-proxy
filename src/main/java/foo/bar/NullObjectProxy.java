package foo.bar;

import java.lang.reflect.*;
import java.util.*;
import java.util.concurrent.*;

/**
 * This class allows to dynamically generate a proxy that implements the
 * Null Object pattern for any given interface
 * @author Mario Fusco
 */
public class NullObjectProxy implements InvocationHandler {
	
	/**
	 * An interface implemented by all the Null Object generated by this proxy
	 */
	public interface NullObject {
		Class<?> getNullClass();
	}

	/**
	 * The class of which this proxy is the Null Oobjct
	 */
	private Class<?> clazz;
	
	private NullObjectProxy(Class<?> clazz) { 
		this.clazz = clazz;
	}
	
	public Class<?> getNullClass() {
		return clazz;
	}
	
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		String methodName = method.getName();
		if (methodName.equals("getNullClass") && (args == null || args.length == 0)) return clazz; 
		
		// it delegates the hashCode and the equals methods to the proxy class
		if (methodName.equals("hashCode") && (args == null || args.length == 0)) return clazz.hashCode(); 
		if (methodName.equals("equals") && args.length == 1 && args[0] instanceof NullObject) return ((NullObject)args[0]).getNullClass() == clazz; 
		
		// it checks if a special return value has been defined for this method call
		Method mockedMethod = getMockedMethod(method);
		if (mockedMethod != null) return mockedMethodValuesMap.get(mockedMethod);
		
		Class<?> returnedType = method.getReturnType();
		if (returnedType == Void.TYPE) return null;
		
		// if the returned type is an interface it returns a Null Object for that interface
		if (returnedType.isInterface()) return nullObjectOf(returnedType);
		
		// it checks if has been defined a default value for this returned type
		try {
			return NullObjectProxy.class.getMethod("null" + returnedType.getSimpleName() + "Value").invoke(NullObjectProxy.class);
		} catch (Exception e) { }

		// it tries to instance an object of the given return type but invoking its empty constructor (if any)
		try {
			return returnedType.newInstance();
		} catch (Exception e) { }
		
		// if all the former strategies fail just return null
		return null;
	}
	
	public static Boolean nullBooleanValue() { return false; }
	public static boolean nullbooleanValue() { return false; }
	public static String nullStringValue() { return ""; }
	public static Date nullDateValue() { return new Date(); }
	public static Integer nullIntegerValue() { return 0; }
	public static int nullintValue() { return 0; }
	public static Long nullLongValue() { return 0L; }
	public static long nulllongValue() { return 0L; }
	public static Double nullDoubleValue() { return 0D; }
	public static double nulldoubleValue() { return 0D; }
	public static Float nullFloatValue() { return 0F; }
	public static float nullfloatValue() { return 0F; }
	public static Character nullCharacterValue() { return ' '; }
	public static char nullcharValue() { return ' '; }
	
	/**
	 * Since the Null Object are stateless by definition they can be cached and reused 
	 */
	private static Map<Class<?>, Object> nullObjectsMap = new ConcurrentHashMap<Class<?>, Object>();
	
	/**
	 * It builds a proxy of the given Class that implements the Null Object pattern for it
	 * @param clazz The clazz of the interface for which a Null Object is going to be generated
	 * @return A proxy of the given Class that implements the Null Object pattern
	 */
	@SuppressWarnings("unchecked")
	public static <T> T nullObjectOf(Class<T> clazz) {
		T nullObject = (T)nullObjectsMap.get(clazz);
		if (nullObject == null) {
			nullObject = (T)Proxy.newProxyInstance(NullObjectProxy.class.getClassLoader(), new Class[] { clazz, NullObject.class }, new NullObjectProxy(clazz));
			nullObjectsMap.put(clazz, nullObject);
		}
		return nullObject; 
	}
	
	private static Map<String, Map<Class<?>, Method>> mockedMethodMap = new ConcurrentHashMap<String, Map<Class<?>, Method>>();
	
	private static Map<Method, Object> mockedMethodValuesMap = new ConcurrentHashMap<Method, Object>();
	
	/**
	 * It allows to define a particular return value for a specific method call
	 * @param clazz The class containing the method 
	 * @param methodName The method name for which a special return value is going to be defined
	 * @param expectedResult The result expected when the named method is invoked
	 * @param parameterTypes The method parameter types
	 */
	public static void setMockedMethod(Class<?> clazz, String methodName, Object expectedResult, Class<?>... parameterTypes) {
		Method m = null;
		try {
			m = clazz.getMethod(methodName, parameterTypes);
		} catch (Exception e) { 
			new RuntimeException("Unable to find the method " + methodName + " in " + clazz.getName());
		}
		mockedMethodValuesMap.put(m, expectedResult);
		Map<Class<?>, Method> methodsMap = mockedMethodMap.get(methodName);
		if (methodsMap == null) {
			methodsMap = new ConcurrentHashMap<Class<?>, Method>();
			mockedMethodMap.put(methodName, methodsMap);
		}
		methodsMap.put(clazz, m);
	}
	
	private static Method getMockedMethod(Method method) {
		Map<Class<?>, Method> methodsMap = mockedMethodMap.get(method.getName());
		if (methodsMap == null) return null;
		for (Map.Entry<Class<?>, Method> mapEntry : methodsMap.entrySet()) {
			if (!mapEntry.getKey().isAssignableFrom(method.getDeclaringClass())) continue;
			Method candidateMethod = mapEntry.getValue();
			if (method.getParameterTypes().length != candidateMethod.getParameterTypes().length) continue;
			return candidateMethod;
		}
		return null;
	}
}
